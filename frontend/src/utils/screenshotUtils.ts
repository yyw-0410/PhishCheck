/**
 * Shared utilities for screenshot handling across views.
 * Provides consistent screenshot placeholder detection, URL generation, and verdict checking.
 */

/**
 * Check if a screenshot URL is likely a placeholder image.
 * Centralizes placeholder detection logic for consistency across views.
 * 
 * NOTE: Static /screenshots/{uuid}.png URLs are VALID screenshots, not placeholders!
 * The placeholder is only when these URLs return the "No Screenshot Available" image,
 * but we can't detect that from the URL alone.
 * 
 * @param url - The screenshot URL to check
 * @returns true if the URL appears to be a placeholder
 */
export function isPlaceholderScreenshot(url: string | null | undefined): boolean {
    if (!url) return true

    const lower = url.toLowerCase()

    // Only check for explicit "no screenshot" text in URL
    if (lower.includes('no screenshot') || lower.includes('no%20screenshot')) {
        return true
    }

    return false
}

/**
 * Generate a liveshot URL for a given target URL.
 * Liveshots are dynamic screenshots generated by urlscan.io on-demand.
 * 
 * @param targetUrl - The URL to capture a screenshot of
 * @param options - Optional configuration for the liveshot
 * @returns The liveshot URL or null if targetUrl is invalid
 */
export function getLiveshotUrl(
    targetUrl: string | null | undefined,
    options: { width?: number; height?: number; cacheBuster?: string } = {}
): string | null {
    if (!targetUrl) return null

    const { width = 400, height = 300, cacheBuster } = options
    const encodedUrl = encodeURIComponent(targetUrl)
    let url = `https://urlscan.io/liveshot/?width=${width}&height=${height}&url=${encodedUrl}`

    if (cacheBuster) {
        url += `&_cb=${cacheBuster}`
    }

    return url
}

/**
 * Verdict values that indicate a scan is still in progress.
 */
const PENDING_VERDICTS = ['pending', 'processing'] as const

/**
 * Check if a verdict indicates the scan is still pending/processing.
 * 
 * @param verdict - The verdict string to check
 * @returns true if the verdict indicates pending status
 */
export function isVerdictPending(verdict: string | null | undefined): boolean {
    if (!verdict) return true
    return PENDING_VERDICTS.includes(verdict.toLowerCase() as typeof PENDING_VERDICTS[number])
}

/**
 * Capitalize the first letter of a string.
 * Used for consistent verdict display formatting.
 * 
 * @param str - The string to capitalize
 * @returns The string with first letter capitalized
 */
export function capitalizeFirst(str: string): string {
    if (!str) return str
    return str.charAt(0).toUpperCase() + str.slice(1)
}

/**
 * Get the best available screenshot URL for a urlscan submission.
 * Uses the following priority:
 * 1. Stored screenshot_url if not a placeholder and scan is complete
 * 2. Liveshot URL as fallback
 * 
 * @param screenshotUrl - The stored screenshot URL
 * @param targetUrl - The URL being scanned (for liveshot fallback)
 * @param isPending - Whether the scan is still pending
 * @param cacheBuster - Optional cache buster for retry functionality
 * @returns The best available screenshot URL or null
 */
export function getBestScreenshotUrl(
    screenshotUrl: string | null | undefined,
    targetUrl: string | null | undefined,
    isPending: boolean,
    cacheBuster?: string
): string | null {
    // Use static screenshot if available and scan is complete
    if (!isPending && screenshotUrl && !isPlaceholderScreenshot(screenshotUrl)) {
        // Add cache buster to force refresh on retry
        if (cacheBuster) {
            const separator = screenshotUrl.includes('?') ? '&' : '?'
            return `${screenshotUrl}${separator}_cb=${cacheBuster}`
        }
        return screenshotUrl
    }

    // Fallback to liveshot URL
    return getLiveshotUrl(targetUrl, { cacheBuster })
}

/**
 * Reactive screenshot state manager for Vue components.
 * Tracks loading, broken, and retry states for screenshots.
 */
export interface ScreenshotState {
    loading: Record<string, boolean>
    broken: Record<string, boolean>
    retryCount: Record<string, number>
}

/**
 * Create initial screenshot state for reactive usage.
 */
export function createScreenshotState(): ScreenshotState {
    return {
        loading: {},
        broken: {},
        retryCount: {},
    }
}

/**
 * Mark a screenshot as loading.
 */
export function markLoading(state: ScreenshotState, key: string): void {
    state.loading[key] = true
}

/**
 * Mark a screenshot as successfully loaded.
 */
export function markLoaded(state: ScreenshotState, key: string): void {
    state.loading[key] = false
    state.broken[key] = false
}

/**
 * Mark a screenshot as broken/failed.
 */
export function markBroken(state: ScreenshotState, key: string): void {
    state.loading[key] = false
    state.broken[key] = true
}

/**
 * Retry loading a broken screenshot.
 * Increments retry count to bust cache and clears broken state.
 */
export function retryScreenshot(state: ScreenshotState, key: string): void {
    state.retryCount[key] = (state.retryCount[key] || 0) + 1
    state.broken[key] = false
    state.loading[key] = true
}

/**
 * Get the retry count for a screenshot (used for cache busting).
 */
export function getRetryCount(state: ScreenshotState, key: string): number {
    return state.retryCount[key] || 0
}

/**
 * Check if a screenshot is currently broken.
 */
export function isBroken(state: ScreenshotState, key: string): boolean {
    return state.broken[key] === true
}

/**
 * Check if a screenshot is currently loading.
 */
export function isLoading(state: ScreenshotState, key: string): boolean {
    return state.loading[key] === true
}
